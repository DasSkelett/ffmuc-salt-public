setACL({'0.0.0.0/0', '::/0'})
-- drop ANY queries sent over udp , not useful for DoT and DoH only servers.
addAction(AndRule({QTypeRule(DNSQType.ANY), TCPRule(false)}), DropAction())
addAction(RegexRule(".*.(10|168.192|(1[6-9]|2[0-9]|3[0-1]).172).in-addr.arpa$"), DropAction())

addLocal("127.0.0.1")

ssl_cert="/etc/letsencrypt/live/doh.ffmuc.net/fullchain.pem"
ssl_key="/etc/letsencrypt/live/doh.ffmuc.net/privkey.pem"

-- listen for DoT on external interface
addTLSLocal("0.0.0.0", ssl_cert, ssl_key, { reusePort=true, interface="vrf_external", tcpFastOpenQueueSize=20 })
addTLSLocal("[::]", ssl_cert, ssl_key, { reusePort=true, interface="vrf_external", tcpFastOpenQueueSize=20 })

-- listen for DoH on localhost for reverse proxy
addDOHLocal("127.0.0.1:445", nil, nil, "/", { reusePort=true })
addDOHLocal("[::1]:445", nil, nil, "/", { reusePort=true })

-- this should be recreated regularly
infolog("Generate new DNSCrypt keys.")
generateDNSCryptCertificate("/var/lib/dnsdist/providerPrivate.key", "/run/dnsdist/resolver.cert", "/run/dnsdist/resolver.key", os.date('%Y%m%d', os.time()), os.time(os.date("!*t")), os.time({year=2025, month=2, day=1, hour=00, minute=00}))

-- listen for DNSCrypt
addDNSCryptBind("0.0.0.0:8443", "2.dnscrypt-cert.ffmuc.net", "/run/dnsdist/resolver.cert", "/run/dnsdist/resolver.key", { reusePort=true, interface="vrf_external" })
addDNSCryptBind("[::]:8443", "2.dnscrypt-cert.ffmuc.net", "/run/dnsdist/resolver.cert", "/run/dnsdist/resolver.key", { reusePort=true, interface="vrf_external" })

-- set number of queries to be allowed per second from an IP but exclude localhost
addAction(AndRule({MaxQPSIPRule(300), NotRule(OrRule({makeRule("127.0.0.1"), makeRule("::1")}))}), DropAction())

{%- for ipaddress in salt["pillar.get"]("netbox:interfaces:vlan3:ipaddresses", []) %}
{%- if ipaddress.family.value == 6 %}
newServer({address="2001:608:a01::40", name="gw01", source="{{ ipaddress["address"].split('/')[0] }}@vrf_external", weight=3})
newServer({address="2001:608:a01::41", name="gw02", source="{{ ipaddress["address"].split('/')[0] }}@vrf_external", weight=3})
newServer({address="2001:608:a01::42", name="gw07", source="{{ ipaddress["address"].split('/')[0] }}@vrf_external", weight=3})
{%- endif %}
{% endfor %}

setServerPolicy(whashed)

{#- some stats #}
addAction({'ffmuc.net'}, NoneAction())
addAction({'ffmuc.bayern'}, NoneAction())
addAction({'freewifi.bayern'}, NoneAction())
addAction({'in-addr.arpa'}, NoneAction())

-- ask authorative servers for ffmuc.net directly
newServer({address="2001:608:a01:ffff::12", name="dns01", pool="auth"})
addAction({'in.ffmuc.net.', 'ext.ffmuc.net'}, PoolAction("auth"))

-- add cache for X possible entries
pc = newPacketCache(100000)
getPool(""):setCache(pc)

{%- set dnsdist_webserver = salt["pillar.get"]("netbox:config_context:dnsdist:webserver", []) %}
{%- if "bind" in dnsdist_webserver %}
webserver("{{ dnsdist_webserver["bind"] }}", "{{ dnsdist_webserver["password"] }}", "{{ dnsdist_webserver["api_token"] }}")
{%- endif -%}
{%- set dnsdist_console = salt["pillar.get"]("netbox:config_context:dnsdist:console", []) %}
{%- if "bind" in dnsdist_console %}
controlSocket("{{ dnsdist_console["bind"] }}")
setKey("{{ dnsdist_console["key"] }}")
{%- endif %}

setMaxUDPOutstanding(65535)
setMaxTCPClientThreads(1000)           -- set X(int) to handle number of maximum tcp clients
setMaxTCPConnectionDuration(120)      -- set X(int) for tcp connection duaration from a connected client. X is number of seconds.
setMaxTCPConnectionsPerClient(10)    -- set X(int) for number of tcp connections from a single client. Useful for rate limiting the concurrent connections.
setMaxTCPQueriesPerConnection(100)    -- set X(int) , similiar to addAction(MaxQPSIPRule(X), DropAction())
